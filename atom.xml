<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晴天·Sunny</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-24T06:58:03.479Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Default</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS排序算法</title>
    <link href="http://yoursite.com/2017/10/24/JS%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/10/24/JS排序算法/</id>
    <published>2017-10-24T03:06:36.000Z</published>
    <updated>2017-10-24T06:58:03.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/sort.png" alt="sort"></p><blockquote><p> 我们平时对计算机中存储的数据执行的两种最常见的操作就是排序和查找，对于计算机的排序和查找的研究，自计算机诞生以来就没有停止过。如今又是大数据，云计算的时代，对数据的排序和查找的速度、效率要求更高，因此要对排序和查找的算法进行专门的数据结构设计，以便让我们对数据的操作更加简洁高效。</p></blockquote><a id="more"></a><h2 id="关于排序算法的说明"><a href="#关于排序算法的说明" class="headerlink" title="关于排序算法的说明"></a>关于排序算法的说明</h2><p>在介绍各个算法之前，我们有必要了解一下评估算法优劣的一些术语：</p><p><strong>稳定：</strong>如果a原本在b前面，当a=b时，排序之后a仍然在b的前面</p><p><strong>不稳定：</strong>如果a原本在b的前面，当a=b时，排序之后a可能会出现在b的后面</p><p><strong>内排序：</strong>所有排序操作都在内存中完成</p><p><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</p><p><strong>时间复杂度：</strong>一个算法执行所耗费的时间</p><p><strong>空间复杂度：</strong>运行完一个程序所需内存的大小</p><h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><p>基本排序算法的核心思想就是对一组数据按照一定的顺序重新排序，其中重排时一般都会用到一组嵌套的 for 循环，外循环会遍历数组的每一项元素，内循环则用于进行元素直接的比较。</p><h3 id="冒泡排序（BuddleSort）"><a href="#冒泡排序（BuddleSort）" class="headerlink" title="冒泡排序（BuddleSort）"></a>冒泡排序（BuddleSort）</h3><p>冒泡排序是比较经典的算法之一，也是排序最慢的算法之一，因为它的实现是非常的容易的。</p><p>冒泡排序的算法思想如下（升序排序）：</p><p>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p><p>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样最终最大数被交换到最后的位置；</p><p>3.除了最后一个元素以外，针对所有的元素重复以上的步骤；</p><p>4.重复步骤1~3，直到排序完成；</p><p>下面我借用网上一张动图，来展示冒泡排序的过程：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/20160916160748389" alt="sort"></p><p>具体的JS实现如下：</p><pre><code>//冒泡排序function bubbleSort ( data ) {var temp = 0;for ( var i = data.length ; i &gt; 0 ; i -- ){    for( var j = 0 ; j &lt; i - 1 ; j++){       if( data[j] &gt; data[j + 1] ){           temp = data[j];           data[j] = data [j+1];           data[j+1] = temp;            }        }    }    return data;}</code></pre><h3 id="选择排序（SelectionSort）"><a href="#选择排序（SelectionSort）" class="headerlink" title="选择排序（SelectionSort）"></a>选择排序（SelectionSort）</h3><p>选择排序是一种比较简单直观的排序算法。它的算法思想是，从数组的开头开始遍历，将第一个元素和其他元素分别进行比较，记录最小的元素，等循环结束之后，将最小的元素放到数组的第一个位置上，然后从数组的第二个位置开始继续执行上述步骤。当进行到数组倒数第二个位置的时候，所有的数据就完成了排序。</p><p>选择排序同样会用到嵌套循环，外循环从数组第一个位置移到倒数第二个位置；内循环从第二个位置移动到数组最后一个位置，查找比当前外循环所指向的元素还要小的元素，每次内循环结束后，都会将最小的值放到合适的位置上。</p><p>同样，我借用网上一张动图，来展示选择排序的过程 ：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/selectionSort" alt="selectionSort"></p><p>具体的JS实现如下：</p><pre><code>//选择排序function selectionSort( data ) {    for( var i = 0; i&lt; data.length ; i++){        var min = data[i];        var temp;        var index = i;        for( var j = i + 1; j&lt; data.length; j++){            if( data[j] &lt; min ){                min = data[j];                index = j;            }        }        temp = data[i];        data[i] = min;        data[index]= temp;    }    return data;}</code></pre><h3 id="插入排序（insertionSort）"><a href="#插入排序（insertionSort）" class="headerlink" title="插入排序（insertionSort）"></a>插入排序（insertionSort）</h3><p>插入排序有点类似人类按字母顺序对数据进行排序，就如同你打扑克牌一样，将摸来的扑克按大小放到合适的位置一样。它的原理就是通过嵌套循环，外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及它后面的元素进行比较；如果外循环中选中的元素比内循环中选中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。</p><p>实现步骤如下：</p><ol><li>从第一个元素开始，该元素默认已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置</li><li>重复步骤2~5，直到排序完成</li></ol><p>它的实现效果图如下：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/insertionSort" alt="insertSort"></p><p>具体的JS实现如下：</p><pre><code>//插入排序function insertionSort( data ) {    var len = data.length;    for (var i = 1; i &lt; len; i++) {        var key = data[i];        var j = i - 1;        while ( j &gt;= 0 &amp;&amp; data[j] &gt; key) {            data[j + 1] = data[j];         j--;      }      data[j + 1] = key;     } return data;}</code></pre><p>其中冒泡排序是最慢的，插入排序是最快的，我们可以在运行的过程中通过 console.time(‘sortName’) 和 console.timeEnd(‘sortName’) 两个输出来看他们的效率如何。</p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28568244&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/sort.png&quot; alt=&quot;sort&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 我们平时对计算机中存储的数据执行的两种最常见的操作就是排序和查找，对于计算机的排序和查找的研究，自计算机诞生以来就没有停止过。如今又是大数据，云计算的时代，对数据的排序和查找的速度、效率要求更高，因此要对排序和查找的算法进行专门的数据结构设计，以便让我们对数据的操作更加简洁高效。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="http://yoursite.com/2017/10/23/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/10/23/Markdown语法学习/</id>
    <published>2017-10-23T09:11:28.000Z</published>
    <updated>2017-10-24T06:57:12.760Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/markdown.png" alt="Markdown"></p><blockquote><p><strong>Markdown</strong> 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p></blockquote><a id="more"></a><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><pre><code>语法：# 一级标题     ## 二级标题         。         。         。      ###### 六级标题</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>unOrder list 1</li></ul><p><code>语法： - unOrder list 1</code></p><ul><li>unOrder list 2</li></ul><p><code>语法： - unOrder list 2</code></p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li>order list 1</li><li>order list 2</li></ol><p><code>语法： 1. order list 1</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p><blockquote><p>例如这样</p></blockquote><pre><code>语法：&gt; 例如这样</code></pre><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 !号</p><h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><p><a href="http://baidu.com" target="_blank" rel="external">Baidu</a></p><pre><code>语法：[Baidu](http://baidu.com)</code></pre><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p><img src="http://mouapp.com/Mou_128.png" alt="Mon icon"></p><pre><code>语法：![Mon icon](http://mouapp.com/Mou_128.png)</code></pre><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。</p><p><strong>粗体</strong></p><p><em>斜体</em></p><pre><code>语法：**粗体**语法：*斜体*</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><pre><code>| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |</code></pre><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p><code>if(true) { do  }</code></p><pre><code>语法：`if(true) {  do  }`</code></pre><p>使用tab可缩进</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要另起一行，连续输入三个星号 <em>*</em> 即可。</p><hr><pre><code>语法：***</code></pre><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=283760&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/markdown.png&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
