<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Default&#39;s Blog</title>
  
  <subtitle>Try Hard And Do Your Best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhouyang1994.cn/"/>
  <updated>2017-11-24T08:12:35.097Z</updated>
  <id>http://zhouyang1994.cn/</id>
  
  <author>
    <name>CDU_ZY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017-11-24日常学习</title>
    <link href="http://zhouyang1994.cn/2017/11/24/2017-11-24%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhouyang1994.cn/2017/11/24/2017-11-24日常学习/</id>
    <published>2017-11-24T06:52:39.000Z</published>
    <updated>2017-11-24T08:12:35.097Z</updated>
    
    <content type="html"><![CDATA[<p>什么是响应式？同一个页面在不同屏幕尺寸下有不同的布局。</p><p>传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就好了，缺点是CSS比较重。</p><a id="more"></a><h2 id="响应式布局方案选择"><a href="#响应式布局方案选择" class="headerlink" title="响应式布局方案选择"></a>响应式布局方案选择</h2><ul><li>CSS3 Media Query（推荐）：媒体查询，兼容到IE9+，但可以通过插件兼容IE6-8</li><li>Flex：弹性布局，兼容性较差（IE10+）</li><li>Grid：网格布局，兼容性更差</li><li>Columns：栅格系统，往往需要依赖于某个UI库，如bootstrap</li></ul><h2 id="CSS3-Media-Query简介"><a href="#CSS3-Media-Query简介" class="headerlink" title="CSS3 Media Query简介"></a>CSS3 Media Query简介</h2><p>利用CSS3 Media Query可以轻松实现不同屏幕宽度时切换不同的页面布局</p><p>兼容性：IE9+</p><p>目前实现CSS3 Media Query对于IE兼容的库比较成熟的有<code>respond.js</code>和<code>css-mediaqueries.js</code>，他们各有优劣</p><ul><li><code>respond.js（推荐）:压缩后1k，只实现了media query中最常用的min-width max-width的兼容；</code></li><li><code>css3-mediaqueries-js:基本实现了所有css3规范中的media query特性的兼容，所以导致压缩有16k，测试反馈其性能远低于respond.js;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span></div><div class="line"><span class="comment">&lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;</span></div><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line"><span class="comment">  &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt;</span></div><div class="line"><span class="comment">  &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></div><div class="line"><span class="comment">&lt;![endif]--&gt;</span></div></pre></td></tr></table></figure><h2 id="CSS3-Media-Query使用"><a href="#CSS3-Media-Query使用" class="headerlink" title="CSS3 Media Query使用"></a>CSS3 Media Query使用</h2><p>引入方式分为内嵌样式和外部样式，建议使用内嵌样式</p><p>使用内嵌样式时，建议将响应式代码写在对应正常样式的下面，不分开书写，以便维护</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 屏幕尺寸大于 480px 时应用该规则</span></div><div class="line">@media screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>: <span class="number">480</span>px) &#123;</div><div class="line">  .header &#123;</div><div class="line">    <span class="built_in">background</span>: red;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 屏幕尺寸小于 800px 时应用该规则</span></div><div class="line">@media screen <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>: <span class="number">800</span>px) &#123;&#125;</div></pre></td></tr></table></figure><p>逻辑操作符：</p><pre><code>and or not only</code></pre><h2 id="断点的选择（页宽）"><a href="#断点的选择（页宽）" class="headerlink" title="断点的选择（页宽）"></a>断点的选择（页宽）</h2><p><img src="http://oyb6f71eo.bkt.clouddn.com/15fec33002ad99a3.webp" alt="size"></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/15fec33003371f62.webp" alt="size"></p><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>一般地，相同的banner，在电脑上需要使用大图，但是手机上面使用小图就好了，不然会造成手机上加载慢浪费流量等问题，响应式图片应运而生。如何实现呢？</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/face" alt="face"></p><h3 id="css3-media-query"><a href="#css3-media-query" class="headerlink" title="css3 media query"></a>css3 media query</h3><p>一个办法是使用backgound-image结合媒体查询，如下所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.banner&#123;</div><div class="line">  <span class="built_in">background</span>-<span class="built_in">image</span>: url(/<span class="keyword">static</span>/large.jpg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media screen <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>: <span class="number">767</span>px)&#123;</div><div class="line">  <span class="built_in">background</span>-<span class="built_in">image</span>: url(/<span class="keyword">static</span>/small.jpg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方法的缺点是对SEO不太友好，因为如果使用img标签还可以写个alt属性。</p><h3 id="picture标签"><a href="#picture标签" class="headerlink" title="picture标签"></a>picture标签</h3><p><a href="picturefill.min.js" title="https://scottjehl.github.io/picturefill/">picturefill.min.js</a>：解决IE等浏览器不支持 的问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"banner_w1000.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 801px)"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"banner_w800.jpg"</span> <span class="attr">media</span>=<span class="string">"(max-width: 800px)"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"banner_w800.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- picturefill.min.js 解决IE等浏览器不支持 &lt;picture&gt; 的问题 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vendor/picturefill.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>如上，如果页面宽度大于800px（PC），则加载大图，而在手机上加载小图。这样写浏览器就只会加载source里面的一张图片。但是如果是用js动态插进去的，它还是会去加载两张，只有写在html里面加载初始化页面的时候才只加载一张。<br>picture必须要写img标签，否则无法显示，对picture的操作最后都是在img上面，例如onload事件是在img标签触发的，picture和source是不会进行layout的，它们的宽和高都是0。<br>另外使用source，还可以对图片格式做一些兼容处理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span> <span class="attr">srcset</span>=<span class="string">"banner.webp"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"banner.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div></pre></td></tr></table></figure><p>webp在保持同等清晰度的情况下，体积可以减少一半，但是目前只有Chrome支持，Safari和firefox一直处于实验阶段，所以其它的浏览器如firefox将会加载jpg格式的照片</p><h3 id="srcset"><a href="#srcset" class="headerlink" title="srcset"></a>srcset</h3><pre><code>&lt;img srcset=&quot;photo_w350.jpg 1x, photo_w640.jpg 2x&quot; src=&quot;photo_w350.jpg&quot; alt=&quot;&quot;&gt;</code></pre><p>如果屏幕的ppi = 1的话则加载1倍图，而ppi = 2则加载2倍图，手机和mac基本上ppi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。<br>如果浏览器不支持srcset，则默认加载src里面的图片。<br>但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载srcset里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有srcset里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有srcset就不用写src了，如果写了src，用户可能是有用的，而使用picture就不会加载两张。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是响应式？同一个页面在不同屏幕尺寸下有不同的布局。&lt;/p&gt;
&lt;p&gt;传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就好了，缺点是CSS比较重。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://zhouyang1994.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="响应式布局，响应式图片" scheme="http://zhouyang1994.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>“两次请求”引出的Web服务器跨域请求访问问题的解决方案</title>
    <link href="http://zhouyang1994.cn/2017/11/21/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%A8%E5%9F%9F%E5%AF%BC%E8%87%B4%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/"/>
    <id>http://zhouyang1994.cn/2017/11/21/web服务器跨域导致两次请求/</id>
    <published>2017-11-21T03:53:10.000Z</published>
    <updated>2017-11-21T09:23:12.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Help…Help，最烦的就是处理跨域请求。最近开发中由于需要给手机Web布置作业添加点击流事件，但是接口在其他域名下面，不可避免的出现了跨域，So，麻烦运维同事在服务端Ngnix上配置了一大堆东西总算解决了，但是惊奇的事情出现了。</p></blockquote><a id="more"></a><p>为什么我发了两次一模一样的请求</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/two_same_request.png" alt="two_same_request"></p><p>第一条请求的Method为OPTIONS，请求无正常数据返回</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/first_request.png" alt="fir_req"><br><img src="http://oyb6f71eo.bkt.clouddn.com/first_res.png" alt="fir_res"></p><p>第二条请求的Method才是真正的GET或者POST，请求才会返回正常的数据。<br><img src="http://oyb6f71eo.bkt.clouddn.com/second_request.png" alt="sec_req"><br><img src="http://oyb6f71eo.bkt.clouddn.com/second_res.png" alt="sec_res"></p><p>代码出问题了？？？仔细检查，没问题啊，添加点击流之前都是正常的呢，为什么呢？百度一下，你就知道。</p><p>第一个OPTIONS的请求是由Web服务器处理跨域访问引发的。</p><p>OPTIONS是一种“预检请求”，浏览器在处理跨域访问的请求时如果判断请求为非简单请求，则会先向服务器发送一条预检请求，根据服务器返回的内容浏览器判断服务器是否允许该请求访问。</p><p>如果web服务器采用<a href="CORS" title="http://www.ruanyifeng.com/blog/2016/04/cors.html">CORS</a>的方式支持跨域访问，在处理复杂请求时这个预检请求是不可避免的。</p><p>而公司web服务器确实采用的是CORS来解决跨域访问的问题，导致我们的每次请求都为复杂请求，从而产生了每次请求都会发送两条请求的现象。</p><p>问题的原因找到了，就要想办法解决这个问题。既然浏览器在处理复杂请求时，不可避免的要发送预检请求，那么能否减少预检请求的次数呢？比如，预检一次设置一个有效期，在有效期内不再重复预检。顺着这个思路，继续搜索相关资料，最终发现设置Access-Control-Max-Age这个参数即可达到预期目标。该参数用来指定本次预检请求的有效期，单位为秒。在服务器上设置该参数之后，问题解决。</p><p>参考：</p><ul><li><a href="http://blog.csdn.net/cnhnnyzhy/article/details/53128179" target="_blank" rel="external">http://blog.csdn.net/cnhnnyzhy/article/details/53128179</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Help…Help，最烦的就是处理跨域请求。最近开发中由于需要给手机Web布置作业添加点击流事件，但是接口在其他域名下面，不可避免的出现了跨域，So，麻烦运维同事在服务端Ngnix上配置了一大堆东西总算解决了，但是惊奇的事情出现了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="跨域" scheme="http://zhouyang1994.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="简单请求" scheme="http://zhouyang1994.cn/tags/%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移至coding</title>
    <link href="http://zhouyang1994.cn/2017/11/20/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3coding/"/>
    <id>http://zhouyang1994.cn/2017/11/20/博客迁移至coding/</id>
    <published>2017-11-20T02:51:39.000Z</published>
    <updated>2017-11-20T06:23:15.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前把博客托管在github，但是由于github服务器处于国外，再加上公司网络时好时坏导致博客打不开或者访问速度很慢，所以想把博客再部署一套到国内的托管平台coding上，国外的访问github上面内容，国内从coding去访问。查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。</p></blockquote><a id="more"></a><h2 id="coding上创建新项目"><a href="#coding上创建新项目" class="headerlink" title="coding上创建新项目"></a>coding上创建新项目</h2><h3 id="添加SSH公钥"><a href="#添加SSH公钥" class="headerlink" title="添加SSH公钥"></a>添加SSH公钥</h3><p>打开<a href="CODING" title="https://coding.net/">CODING</a>（未注册的先自行注册账号）。依次点击左侧 <code>账户-- SSH公钥</code>，进入到添加界面。<br><img src="http://oyb6f71eo.bkt.clouddn.com/addKey.png" alt="addKey"></p><p>依次打开<code>C:\Users\Administrator\.ssh</code>（备注：文件夹可能被隐藏，需自行调整文件夹选项勾选显示隐藏的文件按钮），找到<code>id_rsa.pub</code>文件，用记事本打开，全部复制，粘贴至上面coding公钥添加界面，输入登录密码完成添加。<br><img src="http://oyb6f71eo.bkt.clouddn.com/fingkey_step.png" alt="findKey"></p><p>添加后，在git bash命令输入(备注：会提示选择一些选项，具体的我也忘了，哈哈，差不多就是一路默认/yes)：<br><code>ssh -T git@git.coding.net</code></p><p>如果得到下图所示表示成功：<br><img src="http://oyb6f71eo.bkt.clouddn.com/success.png" alt="success"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>依次点击 <code>项目 -- 添加项目</code>，结果如图：<br><img src="http://oyb6f71eo.bkt.clouddn.com/add_item.png" alt="add"></p><p>完成后请跳转到步骤二中修改配置文件，然后依次执行<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean <span class="comment">// 清除编译文件</span></div><div class="line">hexo g     <span class="comment">// 重新吧编译打包代码</span></div><div class="line">hexo d     <span class="comment">// 发布</span></div></pre></td></tr></table></figure></p><p>成功后能看到代码已被提交至coding中，此时可以通过<code>username.coding.me</code>访问你的项目了。</p><h3 id="开启pages服务"><a href="#开启pages服务" class="headerlink" title="开启pages服务"></a>开启pages服务</h3><p>由于项目仅仅只能通过官方提供的域名方式访问，要想绑定自己的域名则需开启Pages服务。首先打开刚刚创建的项目，找到Pages服务栏，选择<code>部署来源为：master分支</code>(我们将代码提交到master分支上的)，保存后能看到下方多了自定义域名一栏，绑定自己的个性化域名即可。<br><img src="http://oyb6f71eo.bkt.clouddn.com/bind_site.png" alt="bind_site"></p><h3 id="修改DNS解析"><a href="#修改DNS解析" class="headerlink" title="修改DNS解析"></a>修改DNS解析</h3><p>要实现国内访问跳转到coding，国外访问跳转到github，只需要修改DNS解析（PS：我用的阿里云，其他平台的大致一样）<br><img src="http://oyb6f71eo.bkt.clouddn.com/DNS.png" alt="dns"></p><h2 id="主配置文件-config-yml配置"><a href="#主配置文件-config-yml配置" class="headerlink" title="主配置文件_config.yml配置"></a>主配置文件_config.yml配置</h2><p>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy，根据Hexo官方文档需要修改成下面的形式:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">deploy:</span></div><div class="line"><span class="symbol">  type:</span> git</div><div class="line"><span class="symbol">  message:</span> [message]</div><div class="line"><span class="symbol">  repo:</span></div><div class="line"><span class="symbol">    github:</span> <span class="params">&lt;repository url&gt;</span>,[branch]</div><div class="line"><span class="symbol">    gitcafe:</span> <span class="params">&lt;repository url&gt;</span>,[branch]</div></pre></td></tr></table></figure><p>修改后效果：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">deploy</span>:</div><div class="line">  <span class="attribute">type</span>: git</div><div class="line">  <span class="attribute">repo</span>: </div><div class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:Alluretear/Alluretear.github.io</div><div class="line">    <span class="attribute">coding</span>: git<span class="variable">@git</span>.coding.<span class="attribute">net</span>:alluretear/alluretear.git</div><div class="line">  <span class="attribute">branch</span>: master</div><div class="line">  <span class="attribute">message</span>: 博客<span class="number">2.0</span>版本</div></pre></td></tr></table></figure></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前我在百度提交域名网址的时候，一直搜不到自己的博客，查了一些资料才知道Github主动屏蔽了来自于 BaiduSpider的请求，托管到国内coding上刚好顺带解决了这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前把博客托管在github，但是由于github服务器处于国外，再加上公司网络时好时坏导致博客打不开或者访问速度很慢，所以想把博客再部署一套到国内的托管平台coding上，国外的访问github上面内容，国内从coding去访问。查询了多方资料，终于鼓捣出了本地一次部署，同时更新到github以及coding。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="博客" scheme="http://zhouyang1994.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://zhouyang1994.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="迁移" scheme="http://zhouyang1994.cn/tags/%E8%BF%81%E7%A7%BB/"/>
    
      <category term="coding" scheme="http://zhouyang1994.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>package.json文件中外部依赖组件的各种版本号形式及含义</title>
    <link href="http://zhouyang1994.cn/2017/11/17/%20package.json%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E5%BD%A2%E5%BC%8F/"/>
    <id>http://zhouyang1994.cn/2017/11/17/ package.json中的版本号形式/</id>
    <published>2017-11-17T02:23:21.000Z</published>
    <updated>2017-11-22T03:23:41.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近开发公司运营系统时执行npm install发现把所有的依赖包都更新了，导致项目不停在报警告，Why is it automatically updated？查看文档之后发现问题出在了依赖包的版本号形式上。</p></blockquote><a id="more"></a><p>package.json中的dependencies定义了项目依赖的外部组件，这些外部组件的依赖都是带有版本符号以表示被依赖组件的版本范围。查看 package.json 文件时，往往会在 dependencies 下看到各种各样的版本号形式，示例如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dependencies"</span>: &#123;</div><div class="line">  <span class="string">"vue"</span>: <span class="string">"^2.4.2"</span>,</div><div class="line">  <span class="string">"vue-loader"</span>: <span class="string">"1.0.0 - 2.9999.9999"</span>,</div><div class="line">  <span class="string">"vue-router"</span>: <span class="string">"&gt;=1.0.2 &lt;2.1.2"</span>,</div><div class="line">  <span class="string">"vue-style-loader"</span>: <span class="string">"&gt;1.0.2 &lt;=2.3.4"</span>,</div><div class="line">  <span class="string">"vue-template-compiler"</span>: <span class="string">"2.0.1"</span>,</div><div class="line">  <span class="string">"vuex"</span>: <span class="string">"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0"</span>,</div><div class="line">  <span class="string">"webpack"</span>: <span class="string">"http://webpack.com/webpack.tar.gz"</span>,</div><div class="line">  <span class="string">"webpack-bundle-analyzer"</span>: <span class="string">"~1.2"</span>,</div><div class="line">  <span class="string">"webpack-dev-middleware"</span>: <span class="string">"2.x"</span>,</div><div class="line">  <span class="string">"webpack-hot-middleware"</span>: <span class="string">"latest"</span>,</div><div class="line">  <span class="string">"netease"</span>: <span class="string">"file:deps\\netease"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>项目中往往会依赖很多的外部组件，而这些组件都是开源，使用开源的组件时首先要注意的就是它的版本，版本号的差异会造成功能上的很大偏差，搞明白npm中版本符号的含义就是使用组件的基础，npm中的版本符号就是限定版本范围的符号。</p><p>版本号形式是有据可循的，它就是<a href="《语义化版本 2.0.0》" title="http://semver.org/lang/zh-CN/">《语义化版本 2.0.0》</a>， npm 遵循该规范，但做了以下扩展：</p><blockquote><p>版本号的构建号部分允许使用 - 字符，所以 0.2.0-1 在<a href="《语义化版本 2.0.0》" title="http://semver.org/lang/zh-CN/">《语义化版本 2.0.0》</a>中是非法的，却是合法的 npm 语义版本（Semantic Versioning）。</p></blockquote><p>npm 使用 <a href="semver" title="https://github.com/npm/node-semver">semver</a> 包进行版本号解析。</p><h2 id="版本号解析示例"><a href="#版本号解析示例" class="headerlink" title="版本号解析示例"></a>版本号解析示例</h2><h3 id="版本的格式"><a href="#版本的格式" class="headerlink" title="版本的格式"></a>版本的格式</h3><p>major.minor.patch</p><p>主版本号.次版本号.修补版本号</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>必须匹配某个版本</p><pre><code>如：&quot;vue-template-compiler&quot;: &quot;2.0.1&quot;，表示必须依赖2.0.1版</code></pre><h3 id="gt-version"><a href="#gt-version" class="headerlink" title="&gt;version"></a>&gt;version</h3><p>必须大于某个版本</p><pre><code>如：&quot;vue-router&quot;: &quot;&gt;1.0.2&quot;，表示必须大于1.0.2版</code></pre><h3 id="gt-version-1"><a href="#gt-version-1" class="headerlink" title="&gt;=version"></a>&gt;=version</h3><p>可大于或等于某个版本</p><pre><code>如：&quot;vue-router&quot;: &quot;&gt;=1.0.2&quot;，表示可以等于1.0.2 ，也可以大于1.0.2版本</code></pre><h3 id="小于version"><a href="#小于version" class="headerlink" title="小于version"></a>小于version</h3><p>必须小于某个版本 </p><pre><code>如：&quot;vue-router&quot;: &quot;&lt;2.1.2&quot;，表示必须小于2.1.2版本    </code></pre><h3 id="小于-version"><a href="#小于-version" class="headerlink" title="小于=version"></a>小于=version</h3><p>可以小于或等于某个版本</p><pre><code>如：&quot;vue-router&quot;: &quot;&lt;=2.1.2&quot;，表示可以等于2.1.2，也可以小于2.1.2版本</code></pre><h3 id="version-1"><a href="#version-1" class="headerlink" title="~version"></a>~version</h3><p>大概匹配某个版本</p><p>如果minor版本号指定了，那么minor版本号不变，而patch版本号任意</p><p>如果minor和patch版本号未指定，那么minor和patch版本号任意</p><pre><code>如：~1.1.2，表示&gt;=1.1.2 &lt;1.2.0，可以是1.1.2，1.1.3，1.1.4，.....，1.1.n 如：~1.1，表示&gt;=1.1.0 &lt;1.2.0，可以是同上如：~1，表示&gt;=1.0.0 &lt;2.0.0，可以是1.0.0，1.0.1，1.0.2，.....，1.0.n，1.1.n，1.2.n，.....，1.n.n</code></pre><h3 id="version-2"><a href="#version-2" class="headerlink" title="^version"></a>^version</h3><p>兼容某个版本</p><p>版本号中最左边的非0数字的右侧可以任意</p><p>如果缺少某个版本号，则这个版本号的位置可以任意</p><pre><code>如：^1.1.2 ，表示&gt;=1.1.2 &lt;2.0.0，可以是1.1.2，1.1.3，.....，1.1.n，1.2.n，.....，1.n.n如：^0.2.3 ，表示&gt;=0.2.3 &lt;0.3.0，可以是0.2.3，0.2.4，.....，0.2.n如：^0.0，表示 &gt;=0.0.0 &lt;0.1.0，可以是0.0.0，0.0.1，.....，0.0.n</code></pre><h3 id="x-range"><a href="#x-range" class="headerlink" title="x-range"></a>x-range</h3><p>x的位置表示任意版本</p><pre><code>如：&quot;webpack-dev-middleware&quot;: &quot;1.2.x&quot;，表示可以1.2.0，1.2.1，.....，1.2.n</code></pre><h3 id="range"><a href="#range" class="headerlink" title="*-range"></a>*-range</h3><p>任意版本，””也表示任意版本</p><pre><code>如：*，表示&gt;=0.0.0的任意版本</code></pre><h3 id="version1-version2"><a href="#version1-version2" class="headerlink" title="version1 - version2"></a>version1 - version2</h3><p>大于等于version1，小于等于version2</p><pre><code>如：1.1.2 - 1.3.1，表示包括1.1.2和1.3.1以及他们件的任意版本</code></pre><h3 id="range1-range2"><a href="#range1-range2" class="headerlink" title="range1 || range2"></a>range1 || range2</h3><p>满足range1或者满足range2，可以多个范围</p><pre><code>如：&quot;vuex&quot;: &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;，表示满足这3个范围的版本都可以</code></pre><h3 id="latest"><a href="#latest" class="headerlink" title="latest"></a>latest</h3><p>当前发布版本</p><p>这是一个标记（tag，详见 <a href="dist-tag | npm Documentation" title="https://docs.npmjs.com/cli/dist-tag">dist-tag | npm Documentation</a>），默认情况下 npm install 安装的就是这个 latest 标记。 常见的标记还有 next stable beta canary 。</p><p>参考：</p><ul><li><a href="https://docs.npmjs.com/files/package.json" title="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></li><li><a href="https://docs.npmjs.com/misc/semver" title="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">https://docs.npmjs.com/misc/semver</a></li><li><a href="https://github.com/npm/node-semver" title="https://github.com/npm/node-semver" target="_blank" rel="external">https://github.com/npm/node-semver</a></li><li><a href="http://ju.outofmemory.cn/entry/130809" title="http://ju.outofmemory.cn/entry/130809" target="_blank" rel="external">http://ju.outofmemory.cn/entry/130809</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近开发公司运营系统时执行npm install发现把所有的依赖包都更新了，导致项目不停在报警告，Why is it automatically updated？查看文档之后发现问题出在了依赖包的版本号形式上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://zhouyang1994.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="package.json" scheme="http://zhouyang1994.cn/tags/package-json/"/>
    
      <category term="版本号" scheme="http://zhouyang1994.cn/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发中常用函数总结</title>
    <link href="http://zhouyang1994.cn/2017/11/09/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://zhouyang1994.cn/2017/11/09/开发中常用函数总结/</id>
    <published>2017-11-09T03:40:46.000Z</published>
    <updated>2017-11-22T03:14:23.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分享一些经常在开发中使用的函数</p></blockquote><a id="more"></a><h2 id="DateFormater（日期格式化函数）"><a href="#DateFormater（日期格式化函数）" class="headerlink" title="DateFormater（日期格式化函数）"></a>DateFormater（日期格式化函数）</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function <span class="built_in">date</span>(tm, <span class="built_in">format</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (tm === <span class="string">'—'</span>) return <span class="string">'—'</span></div><div class="line">  let <span class="built_in">Time</span> = tm ? new <span class="built_in">Date</span>(tm) : new <span class="built_in">Date</span>()</div><div class="line">  let o = &#123;</div><div class="line">    <span class="string">'M+'</span>: <span class="built_in">Time</span>.getMonth() + <span class="number">1</span>,</div><div class="line">    <span class="string">'d+'</span>: <span class="built_in">Time</span>.getDate(),</div><div class="line">    <span class="string">'H+'</span>: <span class="built_in">Time</span>.getHours(),</div><div class="line">    <span class="string">'m+'</span>: <span class="built_in">Time</span>.getMinutes(),</div><div class="line">    <span class="string">'s+'</span>: <span class="built_in">Time</span>.getSeconds(),</div><div class="line">    <span class="string">'q+'</span>: Math.<span class="built_in">floor</span>((<span class="built_in">Time</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),</div><div class="line">    <span class="string">'S'</span>: <span class="built_in">Time</span>.getMilliseconds()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">format</span> = <span class="built_in">format</span> || <span class="string">'yyyy-MM-dd HH:mm'</span></div><div class="line">  </div><div class="line">  <span class="comment">// RegExp.$1 表示与正则表达式匹配的第一个子匹配项</span></div><div class="line">  <span class="keyword">if</span> (/(y+)/.test(<span class="built_in">format</span>)) <span class="built_in">format</span> = <span class="built_in">format</span>.replace(RegExp.$<span class="number">1</span>, (<span class="built_in">Time</span>.getFullYear() + <span class="string">''</span>).substr(<span class="number">4</span> - RegExp.$<span class="number">1</span>.length))</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (let k <span class="built_in">in</span> o) &#123;</div><div class="line">    <span class="keyword">if</span> (new RegExp(<span class="string">'('</span> + k + <span class="string">')'</span>).test(<span class="built_in">format</span>)) &#123;</div><div class="line">      <span class="built_in">format</span> = <span class="built_in">format</span>.replace(RegExp.$<span class="number">1</span>, RegExp.$<span class="number">1</span>.length === <span class="number">1</span> ? o[k] : (<span class="string">'00'</span> + o[k]).substr((<span class="string">''</span> + o[k]).length))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return <span class="built_in">format</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="预加载图片资源"><a href="#预加载图片资源" class="headerlink" title="预加载图片资源"></a>预加载图片资源</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">preLoadImg</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">  src = (src || <span class="string">''</span>).trim()</div><div class="line">  <span class="keyword">if</span> (!src) <span class="keyword">return</span></div><div class="line">  <span class="keyword">return</span> ((<span class="keyword">new</span> <span class="built_in">window</span>.Image()).src = src)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Function判断"><a href="#Function判断" class="headerlink" title="Function判断"></a>Function判断</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">isFunction</span>(o) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">Object.prototype.toString.call(o)</span> === '[object <span class="keyword">Function</span>]'</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Object判断"><a href="#Object判断" class="headerlink" title="Object判断"></a>Object判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Object]'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Arrary判断"><a href="#Arrary判断" class="headerlink" title="Arrary判断"></a>Arrary判断</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">isArray</span>(o) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">Object.prototype.toString.call(o)</span> === '[object <span class="keyword">Array</span>]'</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="对象合并"><a href="#对象合并" class="headerlink" title="对象合并"></a>对象合并</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> src, copyIsArray, copy, name, options, clone</div><div class="line">  <span class="keyword">let</span> target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;</div><div class="line">  <span class="keyword">let</span> i = <span class="number">1</span></div><div class="line">  <span class="keyword">let</span> length = <span class="built_in">arguments</span>.length</div><div class="line">  <span class="keyword">let</span> deep = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="comment">// Handle a deep copy situation</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'boolean'</span>) &#123;</div><div class="line">    deep = target</div><div class="line"></div><div class="line">    <span class="comment">// skip the boolean and the target</span></div><div class="line">    target = <span class="built_in">arguments</span>[i] || &#123;&#125;</div><div class="line">    i++</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">'object'</span> &amp;&amp; !isFunction(target)) target = &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</div><div class="line">    <span class="comment">// Only deal with non-null/undefined values</span></div><div class="line">    <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</div><div class="line">      <span class="comment">// Extend the base object</span></div><div class="line">      <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</div><div class="line">        src = target[name]</div><div class="line">        copy = options[name]</div><div class="line"></div><div class="line">        <span class="comment">// Prevent never-ending loop</span></div><div class="line">        <span class="keyword">if</span> (target === copy) <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="comment">// Recurse if we're merging plain objects or arrays</span></div><div class="line">        <span class="keyword">if</span> (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = isArray(copy)))) &#123;</div><div class="line">          <span class="keyword">if</span> (copyIsArray) &#123;</div><div class="line">            copyIsArray = <span class="literal">false</span></div><div class="line">            clone = src &amp;&amp; isArray(src) ? src : []</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Never move original objects, clone them</span></div><div class="line">          target[name] = merge(deep, clone, copy)</div><div class="line"></div><div class="line">          <span class="comment">// Don't bring in undefined values</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy !== <span class="literal">undefined</span>) &#123;</div><div class="line">          target[name] = copy</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the modified object</span></div><div class="line">  <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 节流函数 参数：fn，延迟时间，fn参数</span></div><div class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, delay, args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timer)</div><div class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      method(args)</div><div class="line">    &#125;, delay)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">url, file, name, headers, data, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">  xhr.open(<span class="string">'POST'</span>, <span class="built_in">url</span>, <span class="literal">true</span>)</div><div class="line">  <span class="comment">// 自定义配置，不是必须项</span></div><div class="line">  <span class="keyword">var</span> userData = userService.getUserData()</div><div class="line">  <span class="keyword">if</span> (userData) &#123;</div><div class="line">    <span class="keyword">var</span> accessToken = userData.accessToken</div><div class="line">    xhr.setRequestHeader(<span class="string">'access_token'</span>, accessToken)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> form = <span class="keyword">new</span> FormData()</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">    <span class="keyword">if</span> (data.hasOwnProperty(key)) &#123;</div><div class="line">      form.append(key, data[key])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  form.append(data.key || <span class="string">'file'</span>, file)</div><div class="line">  form.append(<span class="string">'filename'</span>, name)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</div><div class="line">    <span class="keyword">if</span> (headers.hasOwnProperty(key)) &#123;</div><div class="line">      xhr.setRequestHeader(key, headers[key])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="number">4</span> &amp;&amp; callback) &#123;</div><div class="line">      callback(xhr.responseText)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  xhr.send(form)</div><div class="line">  <span class="keyword">return</span> xhr</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>  空了再写</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分享一些经常在开发中使用的函数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="代码" scheme="http://zhouyang1994.cn/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JS" scheme="http://zhouyang1994.cn/tags/JS/"/>
    
      <category term="日期格式化" scheme="http://zhouyang1994.cn/tags/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dream It Possible</title>
    <link href="http://zhouyang1994.cn/2017/10/27/Dream%20It%20Possible/"/>
    <id>http://zhouyang1994.cn/2017/10/27/Dream It Possible/</id>
    <published>2017-10-27T06:29:14.000Z</published>
    <updated>2017-11-24T08:09:57.737Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/dream_bg.png" ,="" alt="Dream" class="max_width"></p><a id="more"></a><hr><center><br><font size="4" color="#4CBEF8"><br>I will run, I will climb, I will soar<br>奔跑着，攀爬着，飞翔着<br><br>I’m undefeated<br>没有什么能打败我<br><br>Jumping out of my skin, pull the chord<br>脱离身体的桎梏，拨动琴弦<br><br>Yeah I believe it<br>是的，我相信<br><br>The past, is everything we were don’t make us who we are<br>每个人都有属于自己的过往，但这并不影响我们成为什么样的人<br><br>So I’ll dream, until I make it real, and all I see is stars<br>我勇敢梦，直到梦想实现，看到满天繁星<br><br>Its not until you fall that you fly<br>并非挫败后才想起要努力<br><br>When your dreams come alive you’re unstoppable<br>当你梦想成真，你是不可阻挡的<br><br>Take a shot, chase the sun, find the beautiful<br>为何不试一下，追逐太阳，寻找美好<br><br>We will glow in the dark turning dust to gold<br>我们会在黑暗中闪耀，点石成金<br><br>And we’ll dream it possible possible<br>有梦就有希望<br><br>I will chase, I will reach, I will fly<br>追逐着，冲刺着，飞翔着<br><br>Until I’m breaking, until I’m breaking<br>直到筋疲力尽<br><br>Out of my cage, like a bird in the night<br>脱离牢笼，像夜空中自由的鸟儿<br><br>I know I’m changing, I know I’m changing<br>我知道我在改变<br><br>In, into something big, better than before<br>变得更为强大，从未如此过<br><br>And if it takes, takes a thousand lives<br>无论要付出多少代价<br><br>Then It’s worth fighting for<br>都值得我为此奋斗<br><br>Its not until you fall that you fly<br>并非挫败后才想起要努力<br><br>When your dreams come alive you’re unstoppable<br>当你梦想成真，你是不可阻挡的<br><br>Take a shot, chase the sun, find the beautiful<br>为何不试一下，追逐太阳，寻找美好<br><br>We will glow in the dark turning dust to gold<br>我们会在黑暗中闪耀，点石成金<br><br>And we’ll dream it possible possible possible<br>有梦就有希望<br><br>From the bottom to the top<br>从低谷到巅峰<br><br>We’re sparking wild fire’s<br>我们如烈火般闪耀<br><br>Never quit and never stop<br>从不退缩，从不放弃<br><br>The rest of our lives<br>余生无憾<br><br>From the bottom to the top<br>从低谷到巅峰<br><br>We’re sparking wild fire’s<br>我们如烈火般闪耀<br><br>Never quit and never stop<br>从不退缩，从不放弃<br><br>Its not until you fall that you fly<br>并非挫败后才想起要努力<br><br>When your dreams come alive you’re unstoppable<br>当你梦想成真，你是不可阻挡的<br><br>Take a shot, chase the sun, find the beautiful<br>为何不试一下，追逐太阳，寻找美好<br><br>We will glow in the dark turning dust to gold<br>我们会在黑暗中闪耀，点石成金<br><br>And we’ll dream it possible possible possible<br>有梦就有希望<br><br>And we’ll dream it possible<br>梦想终会实现<br></font><br></center><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/dream_bg.png&quot; ,=&quot;&quot; alt=&quot;Dream&quot; class=&quot;max_width&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://zhouyang1994.cn/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="music" scheme="http://zhouyang1994.cn/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>CSS盒模型详解</title>
    <link href="http://zhouyang1994.cn/2017/10/25/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhouyang1994.cn/2017/10/25/CSS盒模型详解/</id>
    <published>2017-10-25T02:59:15.000Z</published>
    <updated>2017-11-24T08:09:17.530Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/css.png" ,="" alt="CSS" class="max_width"></p><a id="more"></a><h2 id="CSS盒模型详解"><a href="#CSS盒模型详解" class="headerlink" title="CSS盒模型详解"></a>CSS盒模型详解</h2><p>CSS的盒模型是CSS的基础，同时也是难点，这个问题经常在面试中会被问到，属于经典问题了。</p><p>可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。</p><p><strong>盒模型分类：分为IE盒模型、W3C标准盒模型</strong></p><p><strong>IE盒模型和W3C标准盒模型的 <u><strong>区别</strong></u> 是什么？</strong></p><p><strong>1.W3C 标准盒模型：</strong></p><p><em>属性width,height只包含内容content，不包含border和padding。</em></p><p><strong>2.IE 盒模型：</strong></p><p><em>属性width,height包含border和padding，指的是content+padding+border。</em></p><p><strong>在<i>ie8+</i>浏览器中使用哪个盒模型可以由box-sizing(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在<i>ie6,7,8</i>中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。</strong></p><table><thead><tr><th style="text-align:left">盒模型</th><th style="text-align:left">width</th><th style="text-align:left">height</th></tr></thead><tbody><tr><td style="text-align:left">content-box（标准盒模型）</td><td style="text-align:left">内容的宽度</td><td style="text-align:left">内容的高度</td></tr><tr><td style="text-align:left">border-box（IE盒模型）</td><td style="text-align:left">border + padding + 内容的宽度</td><td style="text-align:left">border + padding + 内容的高度</td></tr></tbody></table><p>谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box-Size" alt="boxSize"></p><p><strong>通过代码来对其进行理解，更直观，如下</strong></p><p><strong><em>eg1</em></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">       <span class="attribute">width</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">height</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">background-color</span>:pink;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://oyb6f71eo.bkt.clouddn.com/boxx.png" alt="box"></p><p>此时，盒子大小就是content的大小。</p><hr><p><strong><em>eg2</em></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">       <span class="attribute">width</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">height</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">background-color</span>:pink;</div><div class="line">       <span class="attribute">padding</span>:<span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>效果图如下：</strong></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box.png" alt="box"></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box-1.png" alt="box-1"></p><p>此时，盒子的长宽变成了240x240，显然，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。</p><hr><p><strong><em>eg3</em></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">       <span class="attribute">width</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">height</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">background-color</span>:pink;</div><div class="line">       <span class="attribute">padding</span>:<span class="number">20px</span>;</div><div class="line">       <span class="attribute">border</span>:<span class="number">10px</span> solid black;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>效果图如下：</strong></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box2.png" alt="box2"></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box2-2.png" alt="box2-2"></p><p>此时，盒子的长宽变成了260x260，所以这时盒子大小就等于content+padding+border。</p><hr><p><strong><em>eg4</em></strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">       <span class="attribute">width</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">height</span>:<span class="number">200px</span>;</div><div class="line">       <span class="attribute">background-color</span>:pink;</div><div class="line">       <span class="attribute">padding</span>:<span class="number">20px</span>;</div><div class="line">       <span class="attribute">border</span>:<span class="number">10px</span> solid black;</div><div class="line">       <span class="attribute">margin-bottom</span>:<span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box1</span>&#123;</div><div class="line">       <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">       <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">       <span class="attribute">background</span>: green;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>效果图如下：</strong></p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box3.png" alt="box3"></p><p>此时，盒子的长宽仍为260x260，即盒子的大小并未发生变化。</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/box3-3.png" alt="box3-3"></p><p>可以看到，盒子的底部产生了10px的空白。</p><p><strong>所以说，盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。很多时候，我们会错误地把margin算入，若那样的话，上面这种情形盒子的大小应该是260x270，但实际情况并不是这样的。</strong></p><p><strong>css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定，把margin算进去的那是盒子占据的位置，而不是盒子的大小！</strong></p><font size="3" face="黑体">我们可以试着给上面的粉色方块设置box-sizing属性为border-box发现，会发现：无论我们怎么改border和padding盒子大小始终是定义的width和height。</font><p><strong>我们在编写页面代码时应尽量使用标准的W3C模型(需在页面中声明DOCTYPE类型)，这样可以避免多个浏览器对同一页面的不兼容。</strong></p><p><strong>因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</strong></p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=432506345&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/css.png&quot; ,=&quot;&quot; alt=&quot;CSS&quot; class=&quot;max_width&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="http://zhouyang1994.cn/tags/CSS/"/>
    
      <category term="盒模型" scheme="http://zhouyang1994.cn/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JS排序算法</title>
    <link href="http://zhouyang1994.cn/2017/10/24/JS%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://zhouyang1994.cn/2017/10/24/JS排序算法/</id>
    <published>2017-10-24T03:06:36.000Z</published>
    <updated>2017-11-24T08:10:19.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/js_bg.png" ,="" alt="JS" class="max_width"></p><blockquote><p> 我们平时对计算机中存储的数据执行的两种最常见的操作就是排序和查找，对于计算机的排序和查找的研究，自计算机诞生以来就没有停止过。如今又是大数据，云计算的时代，对数据的排序和查找的速度、效率要求更高，因此要对排序和查找的算法进行专门的数据结构设计，以便让我们对数据的操作更加简洁高效。</p></blockquote><a id="more"></a><h2 id="关于排序算法的说明"><a href="#关于排序算法的说明" class="headerlink" title="关于排序算法的说明"></a>关于排序算法的说明</h2><p>在介绍各个算法之前，我们有必要了解一下评估算法优劣的一些术语：</p><p><strong>稳定：</strong>如果a原本在b前面，当a=b时，排序之后a仍然在b的前面</p><p><strong>不稳定：</strong>如果a原本在b的前面，当a=b时，排序之后a可能会出现在b的后面</p><p><strong>内排序：</strong>所有排序操作都在内存中完成</p><p><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</p><p><strong>时间复杂度：</strong>一个算法执行所耗费的时间</p><p><strong>空间复杂度：</strong>运行完一个程序所需内存的大小</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/sort.png" alt="sort"></p><h2 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h2><p>基本排序算法的核心思想就是对一组数据按照一定的顺序重新排序，其中重排时一般都会用到一组嵌套的 for 循环，外循环会遍历数组的每一项元素，内循环则用于进行元素直接的比较。</p><h3 id="冒泡排序（BuddleSort）"><a href="#冒泡排序（BuddleSort）" class="headerlink" title="冒泡排序（BuddleSort）"></a>冒泡排序（BuddleSort）</h3><p>冒泡排序是比较经典的算法之一，也是排序最慢的算法之一，因为它的实现是非常的容易的。</p><p>冒泡排序的算法思想如下（升序排序）：</p><p>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p><p>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样最终最大数被交换到最后的位置；</p><p>3.除了最后一个元素以外，针对所有的元素重复以上的步骤；</p><p>4.重复步骤1~3，直到排序完成；</p><p>下面我借用网上一张动图，来展示冒泡排序的过程：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/20160916160748389" alt="sort"></p><p>具体的JS实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序</span></div><div class="line">function bubbleSort ( <span class="keyword">data</span> ) &#123;</div><div class="line"><span class="keyword">var</span> temp = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="keyword">data</span>.length ; i &gt; <span class="number">0</span> ; i -- )&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; i - <span class="number">1</span> ; j++)&#123;</div><div class="line">       <span class="keyword">if</span>( <span class="keyword">data</span>[j] &gt; <span class="keyword">data</span>[j + <span class="number">1</span>] )&#123;</div><div class="line">           temp = <span class="keyword">data</span>[j];</div><div class="line">           <span class="keyword">data</span>[j] = <span class="keyword">data</span> [j+<span class="number">1</span>];</div><div class="line">           <span class="keyword">data</span>[j+<span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序（SelectionSort）"><a href="#选择排序（SelectionSort）" class="headerlink" title="选择排序（SelectionSort）"></a>选择排序（SelectionSort）</h3><p>选择排序是一种比较简单直观的排序算法。它的算法思想是，从数组的开头开始遍历，将第一个元素和其他元素分别进行比较，记录最小的元素，等循环结束之后，将最小的元素放到数组的第一个位置上，然后从数组的第二个位置开始继续执行上述步骤。当进行到数组倒数第二个位置的时候，所有的数据就完成了排序。</p><p>选择排序同样会用到嵌套循环，外循环从数组第一个位置移到倒数第二个位置；内循环从第二个位置移动到数组最后一个位置，查找比当前外循环所指向的元素还要小的元素，每次内循环结束后，都会将最小的值放到合适的位置上。</p><p>同样，我借用网上一张动图，来展示选择排序的过程 ：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/selectionSort" alt="selectionSort"></p><p>具体的JS实现如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//选择排序</div><div class="line"><span class="function"><span class="keyword">function</span></span> selectionSort( <span class="keyword">data</span> ) &#123;</div><div class="line">    for( var i = <span class="number">0</span>; i&lt; <span class="keyword">data</span>.length ; i++)&#123;</div><div class="line">        var <span class="built_in">min</span> = <span class="keyword">data</span>[i];</div><div class="line">        var temp;</div><div class="line">        var <span class="built_in">index</span> = i;</div><div class="line">        for( var j = i + <span class="number">1</span>; j&lt; <span class="keyword">data</span>.length; j++)&#123;</div><div class="line">            <span class="keyword">if</span>( <span class="keyword">data</span>[j] &lt; <span class="built_in">min</span> )&#123;</div><div class="line">                <span class="built_in">min</span> = <span class="keyword">data</span>[j];</div><div class="line">                <span class="built_in">index</span> = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        temp = <span class="keyword">data</span>[i];</div><div class="line">        <span class="keyword">data</span>[i] = <span class="built_in">min</span>;</div><div class="line">        <span class="keyword">data</span>[<span class="built_in">index</span>]= temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序（insertionSort）"><a href="#插入排序（insertionSort）" class="headerlink" title="插入排序（insertionSort）"></a>插入排序（insertionSort）</h3><p>插入排序有点类似人类按字母顺序对数据进行排序，就如同你打扑克牌一样，将摸来的扑克按大小放到合适的位置一样。它的原理就是通过嵌套循环，外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及它后面的元素进行比较；如果外循环中选中的元素比内循环中选中的元素小，那么数组元素会向右移动，为内循环中的这个元素腾出位置。</p><p>实现步骤如下：</p><ol><li>从第一个元素开始，该元素默认已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置</li><li>重复步骤2~5，直到排序完成</li></ol><p>它的实现效果图如下：</p><p><img src="http://oyb6f71eo.bkt.clouddn.com/insertionSort" alt="insertSort"></p><p>具体的JS实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入排序</span></div><div class="line">function insertionSort( <span class="keyword">data</span> ) &#123;</div><div class="line">    <span class="keyword">var</span> len = <span class="keyword">data</span>.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">var</span> key = <span class="keyword">data</span>[i];</div><div class="line">        <span class="keyword">var</span> j = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">data</span>[j] &gt; key) &#123;</div><div class="line">            <span class="keyword">data</span>[j + <span class="number">1</span>] = <span class="keyword">data</span>[j];</div><div class="line">         j--;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">data</span>[j + <span class="number">1</span>] = key;</div><div class="line">     &#125;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中冒泡排序是最慢的，插入排序是最快的，我们可以在运行的过程中通过 console.time(‘sortName’) 和 console.timeEnd(‘sortName’) 两个输出来看他们的效率如何。</p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28568244&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/js_bg.png&quot; ,=&quot;&quot; alt=&quot;JS&quot; class=&quot;max_width&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 我们平时对计算机中存储的数据执行的两种最常见的操作就是排序和查找，对于计算机的排序和查找的研究，自计算机诞生以来就没有停止过。如今又是大数据，云计算的时代，对数据的排序和查找的速度、效率要求更高，因此要对排序和查找的算法进行专门的数据结构设计，以便让我们对数据的操作更加简洁高效。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://zhouyang1994.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JS" scheme="http://zhouyang1994.cn/tags/JS/"/>
    
      <category term="算法" scheme="http://zhouyang1994.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="http://zhouyang1994.cn/2017/10/23/Markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhouyang1994.cn/2017/10/23/Markdown语法学习/</id>
    <published>2017-10-23T09:11:28.000Z</published>
    <updated>2017-11-24T08:10:34.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oyb6f71eo.bkt.clouddn.com/markdown.png" ,="" alt="Markdown" class="max_width"></p><blockquote><p><strong>Markdown</strong> 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p></blockquote><a id="more"></a><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">语法：# 一级标题</div><div class="line">     ## 二级标题</div><div class="line">         。</div><div class="line">         。</div><div class="line">         。</div><div class="line">      ###### 六级标题</div></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>unOrder list 1</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">` 语法： - unOrder list <span class="number">1</span> `</div></pre></td></tr></table></figure><ul><li>unOrder list 2</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">` 语法： - unOrder list <span class="number">2</span> `</div></pre></td></tr></table></figure><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li>order list 1</li><li>order list 2</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">` 语法： <span class="number">1</span>. <span class="keyword">order</span> <span class="title">list</span> <span class="number">1</span> `</div></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p><blockquote><p>例如这样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：&gt; 例如这样</div></pre></td></tr></table></figure><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 !号</p><h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><p><a href="http://baidu.com" target="_blank" rel="external">Baidu</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：[<span class="string">Baidu</span>](<span class="link">http://baidu.com</span>)</div></pre></td></tr></table></figure><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p><img src="http://mouapp.com/Mou_128.png" alt="Mon icon"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：![<span class="string">Mon icon</span>](<span class="link">http://mouapp.com/Mou_128.png</span>)</div></pre></td></tr></table></figure><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。</p><p><strong>粗体</strong></p><p><em>斜体</em></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">语法：*<span class="strong">*粗体*</span><span class="strong">*</span></div><div class="line"><span class="strong">语法：*</span>斜体<span class="strong">*</span></div></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">| Tables        |</span> Are           <span class="params">| Cool  |</span></div><div class="line"></div><div class="line"><span class="params">| ------------- |</span><span class="symbol">:-------------</span><span class="symbol">:|</span> -----<span class="symbol">:|</span></div><div class="line"></div><div class="line"><span class="params">| col 3 is      |</span> right-aligned <span class="params">| $1600 |</span></div><div class="line"></div><div class="line"><span class="params">| col 2 is      |</span> centered      <span class="params">|   $12 |</span></div><div class="line"></div><div class="line"><span class="params">| zebra stripes |</span> are neat      <span class="params">|    $1 |</span></div></pre></td></tr></table></figure><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p><code>if(true) { do  }</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：`<span class="javascript"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;  <span class="keyword">do</span>  &#125;</span>`</div></pre></td></tr></table></figure><p>使用tab可缩进</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要另起一行，连续输入三个星号 <em>*</em> 即可。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法：<span class="emphasis">***</span></div></pre></td></tr></table></figure><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=791255735&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oyb6f71eo.bkt.clouddn.com/markdown.png&quot; ,=&quot;&quot; alt=&quot;Markdown&quot; class=&quot;max_width&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://zhouyang1994.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://zhouyang1994.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Markdown" scheme="http://zhouyang1994.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
